"use strict";
exports.__esModule = true;
exports.Base16 = exports.Base32 = exports.Base64 = void 0;
var BITS = 8;
var Base64;
(function (Base64) {
    var OUTPUT_GROUPS = 4;
    var BASE64_BITS = 6;
    var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890+/';
    var options = { alphabet: alphabet, decodedBits: BASE64_BITS, outputGroups: OUTPUT_GROUPS };
    function encode(toEncode) {
        return BaseCoding.encode(toEncode, options);
    }
    Base64.encode = encode;
    function decode(toDecode) {
        return BaseCoding.decode(toDecode, options);
    }
    Base64.decode = decode;
})(Base64 = exports.Base64 || (exports.Base64 = {}));
var Base32;
(function (Base32) {
    var OUTPUT_GROUPS = 8;
    var BASE32_BITS = 5;
    var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    var options = { alphabet: alphabet, decodedBits: BASE32_BITS, outputGroups: OUTPUT_GROUPS };
    function encode(toEncode) {
        return BaseCoding.encode(toEncode, options);
    }
    Base32.encode = encode;
    function decode(toDecode) {
        return BaseCoding.decode(toDecode, options);
    }
    Base32.decode = decode;
})(Base32 = exports.Base32 || (exports.Base32 = {}));
var Base16;
(function (Base16) {
    var OUTPUT_GROUPS = 2;
    var BASE16_BITS = 4;
    var alphabet = '0123456789ABCDEF';
    var options = { alphabet: alphabet, decodedBits: BASE16_BITS, outputGroups: OUTPUT_GROUPS };
    function encode(toEncode) {
        return BaseCoding.encode(toEncode, options);
    }
    Base16.encode = encode;
    function decode(toDecode) {
        return BaseCoding.decode(toDecode, options);
    }
    Base16.decode = decode;
})(Base16 = exports.Base16 || (exports.Base16 = {}));
var BaseCoding = /** @class */ (function () {
    function BaseCoding() {
    }
    BaseCoding.encode = function (toEncode, options) {
        var alphabet = options.alphabet, decodedBits = options.decodedBits, outputGroups = options.outputGroups;
        var bytes = '';
        var result = '';
        for (var i = 0; i < toEncode.length; ++i) {
            var charCode = toEncode.charCodeAt(i);
            bytes = bytes.concat(BaseCoding.addLeadingZeros(charCode.toString(2)));
        }
        bytes = BaseCoding.addTrailingZeros(bytes, decodedBits);
        for (var i = 0; i < bytes.length; i += decodedBits) {
            var index = parseInt(bytes.substr(i, decodedBits), 2);
            var char = alphabet.charAt(index);
            result = result.concat(char.toString());
        }
        result = BaseCoding.addPadding(result, outputGroups);
        return result;
    };
    BaseCoding.decode = function (toDecode, options) {
        var alphabet = options.alphabet, decodedBits = options.decodedBits, outputGroups = options.outputGroups;
        if (toDecode.length % outputGroups !== 0) {
            console.warn("Length of encoded data is not a multiple of " + outputGroups + ":", toDecode.length);
            toDecode = BaseCoding.addPadding(toDecode, outputGroups);
            // throw new Error('Invalid length of encoded message.');
        }
        var indexOfPadding = toDecode.indexOf(BaseCoding.padding);
        var encoded = indexOfPadding > -1 ? toDecode.substring(0, indexOfPadding) : toDecode;
        var bytes = '';
        for (var i = 0; i < encoded.length; ++i) {
            var char = encoded.charAt(i);
            var baseByte = BaseCoding.addLeadingZeros(alphabet.indexOf(char).toString(2), decodedBits);
            bytes = bytes.concat(baseByte);
        }
        var decoded = '';
        for (var i = 0; i < bytes.length; i += BITS) {
            var charCode = parseInt(bytes.substr(i, BITS), 2);
            if (charCode === 0) {
                continue;
            }
            if (charCode >= 1 && charCode < 32) {
                throw new Error("Unknown charakter " + charCode + " after " + i + " bits.");
            }
            decoded = decoded.concat(String.fromCharCode(charCode));
        }
        return decoded;
    };
    BaseCoding.addTrailingZeros = function (input, bits) {
        var result = input;
        while (result.length % bits !== 0) {
            result = result.concat('0');
        }
        return result;
    };
    BaseCoding.addLeadingZeros = function (input, size) {
        if (size === void 0) { size = BITS; }
        var result = input;
        while (result.length % size !== 0) {
            result = "0" + result;
        }
        return result;
    };
    BaseCoding.addPadding = function (input, size) {
        var result = input;
        while (result.length % size !== 0) {
            result = result.concat(BaseCoding.padding);
        }
        return result;
    };
    BaseCoding.padding = '=';
    return BaseCoding;
}());
