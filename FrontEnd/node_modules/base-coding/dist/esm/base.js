const BITS = 8;
export var Base64;
(function (Base64) {
    const OUTPUT_GROUPS = 4;
    const BASE64_BITS = 6;
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890+/';
    const options = { alphabet, decodedBits: BASE64_BITS, outputGroups: OUTPUT_GROUPS };
    function encode(toEncode) {
        return BaseCoding.encode(toEncode, options);
    }
    Base64.encode = encode;
    function decode(toDecode) {
        return BaseCoding.decode(toDecode, options);
    }
    Base64.decode = decode;
})(Base64 || (Base64 = {}));
export var Base32;
(function (Base32) {
    const OUTPUT_GROUPS = 8;
    const BASE32_BITS = 5;
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    const options = { alphabet, decodedBits: BASE32_BITS, outputGroups: OUTPUT_GROUPS };
    function encode(toEncode) {
        return BaseCoding.encode(toEncode, options);
    }
    Base32.encode = encode;
    function decode(toDecode) {
        return BaseCoding.decode(toDecode, options);
    }
    Base32.decode = decode;
})(Base32 || (Base32 = {}));
export var Base16;
(function (Base16) {
    const OUTPUT_GROUPS = 2;
    const BASE16_BITS = 4;
    const alphabet = '0123456789ABCDEF';
    const options = { alphabet, decodedBits: BASE16_BITS, outputGroups: OUTPUT_GROUPS };
    function encode(toEncode) {
        return BaseCoding.encode(toEncode, options);
    }
    Base16.encode = encode;
    function decode(toDecode) {
        return BaseCoding.decode(toDecode, options);
    }
    Base16.decode = decode;
})(Base16 || (Base16 = {}));
class BaseCoding {
    static encode(toEncode, options) {
        const { alphabet, decodedBits, outputGroups } = options;
        let bytes = '';
        let result = '';
        for (let i = 0; i < toEncode.length; ++i) {
            const charCode = toEncode.charCodeAt(i);
            bytes = bytes.concat(BaseCoding.addLeadingZeros(charCode.toString(2)));
        }
        bytes = BaseCoding.addTrailingZeros(bytes, decodedBits);
        for (let i = 0; i < bytes.length; i += decodedBits) {
            const index = parseInt(bytes.substr(i, decodedBits), 2);
            const char = alphabet.charAt(index);
            result = result.concat(char.toString());
        }
        result = BaseCoding.addPadding(result, outputGroups);
        return result;
    }
    static decode(toDecode, options) {
        const { alphabet, decodedBits, outputGroups } = options;
        if (toDecode.length % outputGroups !== 0) {
            console.warn(`Length of encoded data is not a multiple of ${outputGroups}:`, toDecode.length);
            toDecode = BaseCoding.addPadding(toDecode, outputGroups);
        }
        const indexOfPadding = toDecode.indexOf(BaseCoding.padding);
        const encoded = indexOfPadding > -1 ? toDecode.substring(0, indexOfPadding) : toDecode;
        let bytes = '';
        for (let i = 0; i < encoded.length; ++i) {
            const char = encoded.charAt(i);
            const baseByte = BaseCoding.addLeadingZeros(alphabet.indexOf(char).toString(2), decodedBits);
            bytes = bytes.concat(baseByte);
        }
        let decoded = '';
        for (let i = 0; i < bytes.length; i += BITS) {
            const charCode = parseInt(bytes.substr(i, BITS), 2);
            if (charCode === 0) {
                continue;
            }
            if (charCode >= 1 && charCode < 32) {
                throw new Error(`Unknown charakter ${charCode} after ${i} bits.`);
            }
            decoded = decoded.concat(String.fromCharCode(charCode));
        }
        return decoded;
    }
    static addTrailingZeros(input, bits) {
        let result = input;
        while (result.length % bits !== 0) {
            result = result.concat('0');
        }
        return result;
    }
    static addLeadingZeros(input, size = BITS) {
        let result = input;
        while (result.length % size !== 0) {
            result = `0${result}`;
        }
        return result;
    }
    static addPadding(input, size) {
        let result = input;
        while (result.length % size !== 0) {
            result = result.concat(BaseCoding.padding);
        }
        return result;
    }
}
BaseCoding.padding = '=';
//# sourceMappingURL=base.js.map