"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FidoService = void 0;
var tslib_1 = require("tslib");
var crypto_1 = tslib_1.__importDefault(require("crypto"));
var jwk_to_pem_1 = tslib_1.__importDefault(require("jwk-to-pem"));
var fido_helper_1 = require("../lib/fido-helper");
var fido_validator_1 = require("../lib/fido-validator");
var FidoService = /** @class */ (function () {
    function FidoService() {
    }
    FidoService.getRegisterOptions = function (args) {
        var publicKeyAlgs = args.publicKeyAlgs || [-7, -257, -258, -259, -35, -36, -37, -38, -39, -8]; // -7 => 'ES256', -257 => 'RS256'
        return {
            challenge: fido_helper_1.FidoHelper.createChallenge(),
            rp: {
                name: args.rpName || 'http://localhost:8000'
            },
            user: {
                id: args.userId ||
                    Buffer.from(Uint8Array.from(fido_helper_1.FidoHelper.randomNumber(8), function (c) { return c.charCodeAt(0); })).toString('base64'),
                name: args.username,
                displayName: args.username
            },
            extensions: {
                txAuthSimple: ''
            },
            pubKeyCredParams: publicKeyAlgs.map(function (alg) { return ({ alg: alg, type: 'public-key' }); }),
            authenticatorSelection: {
                residentKey: 'discouraged',
                requireResidentKey: false,
                authenticatorAttachment: args.authenticatorAttachment,
                userVerification: 'preferred'
            },
            timeout: 60000,
            attestation: 'direct'
        };
    };
    FidoService.getLoginOptions = function (credentialId) {
        var publicKeyCredentialRequestOptions = {
            challenge: fido_helper_1.FidoHelper.createChallenge(),
            allowCredentials: [
                {
                    id: Buffer.from(Uint8Array.from(Buffer.from(credentialId, 'base64').toString('hex'), function (c) { return c.charCodeAt(0); })).toString('base64'),
                    type: 'public-key',
                    transports: ['usb', 'ble', 'nfc']
                },
                {
                    id: Buffer.from(Uint8Array.from(Buffer.from(credentialId, 'base64').toString('hex'), function (c) { return c.charCodeAt(0); })).toString('base64'),
                    type: 'public-key',
                    transports: ['usb', 'ble', 'nfc']
                }
            ],
            userVerification: 'preferred',
            timeout: 60000
        };
        return publicKeyCredentialRequestOptions;
    };
    FidoService.decodeAttestationObject = function (credential) {
        var authData = fido_helper_1.FidoHelper.decodeAttestation(credential).authData;
        var publicKeyCose = fido_helper_1.FidoHelper.fromBufferToArrayBuffer(authData.cosePublicKeyBuffer);
        var publicKeyJwk = fido_helper_1.FidoHelper.coseToJwk(publicKeyCose);
        var publicKeyPem = jwk_to_pem_1.default(publicKeyJwk);
        return {
            publicKeyBytes: authData.cosePublicKeyBuffer,
            publicKeyPem: publicKeyPem,
            credentialId: authData.credIdBuffer,
            counter: authData.counter
        };
    };
    FidoService.verifyAttestationObject = function (credential, expectations) {
        var _a = fido_helper_1.FidoHelper.decodeAttestation(credential), clientData = _a.clientData, authData = _a.authData;
        fido_validator_1.FidoValidator.validate(clientData, expectations, 'webauthn.create');
        var publicKeyCose = fido_helper_1.FidoHelper.fromBufferToArrayBuffer(authData.cosePublicKeyBuffer);
        var publicKeyJwk = fido_helper_1.FidoHelper.coseToJwk(publicKeyCose);
        var publicKeyPem = jwk_to_pem_1.default(publicKeyJwk);
        return {
            publicKeyBytes: authData.cosePublicKeyBuffer,
            publicKeyPem: publicKeyPem,
            credentialId: authData.credIdBuffer,
            counter: authData.counter
        };
    };
    FidoService.verifySignature = function (credential, expectations) {
        var _a = fido_helper_1.FidoHelper.decode(credential.response.clientDataJSON, credential.response.authenticatorData), clientData = _a.clientData, authData = _a.authData;
        fido_validator_1.FidoValidator.validate(clientData, expectations, 'webauthn.get');
        var hash = crypto_1.default.createHash('sha256');
        hash.update(Buffer.from(credential.response.clientDataJSON, 'base64'));
        var digest = hash.digest();
        var verify = crypto_1.default.createVerify('sha256');
        verify.write(Buffer.from(credential.response.authenticatorData, 'base64'));
        verify.write(digest);
        verify.end();
        var signature = Buffer.from(credential.response.signature, 'base64');
        var isValid = verify.verify(expectations.publicKeyPem, signature);
        if (!isValid) {
            throw new Error('Signature is invalid!');
        }
    };
    return FidoService;
}());
exports.FidoService = FidoService;
