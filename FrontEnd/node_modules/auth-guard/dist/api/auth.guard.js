"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthGuard = void 0;
var implementations_1 = require("../lib/authentication/implementations");
var errors_1 = require("../lib/core/errors");
var util_1 = require("../lib/util");
var AuthGuard = /** @class */ (function () {
    function AuthGuard(options) {
        this.authenticators = {};
        var logger = options.logger, domain = options.domain, expectedOrigins = options.expectedOrigins;
        var logHandler = logger || {};
        this.logger = {
            log: typeof logHandler.log === 'function' ? function () {
                var m = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    m[_i] = arguments[_i];
                }
                return logHandler.log.apply(logHandler, m);
            } : function () {
                var m = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    m[_i] = arguments[_i];
                }
                return util_1.Logger.log.apply(util_1.Logger, m);
            },
            warn: typeof logHandler.warn === 'function' ? function () {
                var m = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    m[_i] = arguments[_i];
                }
                return logHandler.warn.apply(logHandler, m);
            } : function () {
                var m = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    m[_i] = arguments[_i];
                }
                return util_1.Logger.warn.apply(util_1.Logger, m);
            },
            debug: typeof logHandler.debug === 'function' ? function () {
                var m = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    m[_i] = arguments[_i];
                }
                return logHandler.debug.apply(logHandler, m);
            } : function () {
                var m = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    m[_i] = arguments[_i];
                }
                return util_1.Logger.debug.apply(util_1.Logger, m);
            },
            error: typeof logHandler.error === 'function' ? function () {
                var m = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    m[_i] = arguments[_i];
                }
                return logHandler.error.apply(logHandler, m);
            } : function () {
                var m = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    m[_i] = arguments[_i];
                }
                return util_1.Logger.error.apply(util_1.Logger, m);
            }
        };
        this.domain = domain || 'authentication-server@example.com';
        this.expectedOrigins = expectedOrigins ? [].concat(expectedOrigins) : ['http://localhost:8000'];
        this.initAuthenticators();
    }
    AuthGuard.prototype.register = function (user, values) {
        if (!Object.keys(this.authenticators).length) {
            throw new errors_1.AuthenticationException('No authenticators provided!');
        }
        for (var _i = 0, _a = user.authenticationTypes; _i < _a.length; _i++) {
            var key = _a[_i];
            if (!this.authenticators[key]) {
                throw new errors_1.AuthenticationException("Authenticator " + key + " not provided!");
            }
            user = this.authenticators[key].prepareAuthenticationType(user, values ? values[key] : null);
        }
        return user;
    };
    AuthGuard.prototype.login = function (user, values) {
        var _a;
        var missingTypes = {};
        if (!Object.keys(this.authenticators).length) {
            throw new errors_1.AuthenticationException('No authenticators provided!');
        }
        for (var _i = 0, _b = user.authenticationTypes; _i < _b.length; _i++) {
            var key = _b[_i];
            if (!this.authenticators[key]) {
                throw new errors_1.AuthenticationException("Authenticator " + key + " not provided!");
            }
            var result = (_a = this.authenticators[key]) === null || _a === void 0 ? void 0 : _a.isAuthenticationTypeMissing(user, values[key]);
            this.logger.debug('Result from authenticationType:', result);
            if (result === null || result === void 0 ? void 0 : result.missing) {
                missingTypes[key] = result.additionalData;
            }
        }
        if (!!Object.keys(missingTypes).length) {
            throw new errors_1.MissingAuthenticationTypeException(user, missingTypes);
        }
    };
    AuthGuard.prototype.getAvailableAuthenticators = function () {
        return Object.keys(this.authenticators);
    };
    AuthGuard.prototype.initAuthenticators = function () {
        this.authenticators = {
            password: new implementations_1.PasswordAuthenticator(this.logger),
            totp: new implementations_1.TotpAuthenticator(this.logger),
            email: new implementations_1.EmailAuthenticator(this.logger, { domain: this.domain }),
            fido: new implementations_1.FidoAuthenticator(this.logger, { expectedOrigins: this.expectedOrigins })
        };
    };
    return AuthGuard;
}());
exports.AuthGuard = AuthGuard;
