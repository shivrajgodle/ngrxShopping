"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FidoAuthenticator = void 0;
var tslib_1 = require("tslib");
var custom_fido_library_1 = require("custom-fido-library");
var errors_1 = require("../../core/errors");
var authentication_types_1 = require("../../core/models/authentication-types");
var base_authenticator_1 = require("./base-authenticator");
var base_coding_1 = require("base-coding");
function isCredentialObject(obj) {
    return (obj.hasOwnProperty('id') &&
        obj.hasOwnProperty('rawId') &&
        obj.hasOwnProperty('response') &&
        obj.hasOwnProperty('type'));
}
var FidoAuthenticator = /** @class */ (function (_super) {
    tslib_1.__extends(FidoAuthenticator, _super);
    function FidoAuthenticator(logger, options) {
        var _this = _super.call(this, logger) || this;
        _this.pendingChallenges = {};
        _this.expectedOrigins = options.expectedOrigins;
        return _this;
    }
    FidoAuthenticator.prototype.isAuthenticationTypeMissing = function (user, value) {
        var _a;
        if (!value) {
            var additionalData = custom_fido_library_1.FidoService.getLoginOptions((_a = user.fido) === null || _a === void 0 ? void 0 : _a.credentialId);
            this.logger.log("Sende Challenge \"" + additionalData.challenge + "\" an Client.");
            this.pendingChallenges[user.userId] = additionalData.challenge;
            return { missing: true, additionalData: additionalData };
        }
        else {
            this.checkSignature(user, value);
            return { missing: false };
        }
    };
    FidoAuthenticator.prototype.prepareAuthenticationType = function (user, value) {
        if (!value || !isCredentialObject(value)) {
            this.onChallenge(user, value);
        }
        if (value && isCredentialObject(value)) {
            return this.onResponse(user, value);
        }
        throw new errors_1.AuthenticationException("Unhandled value " + value + " for user " + user.username + "!");
    };
    FidoAuthenticator.prototype.onChallenge = function (user, value) {
        var additionalData = custom_fido_library_1.FidoService.getRegisterOptions({
            authenticatorAttachment: (value === null || value === void 0 ? void 0 : value.authenticatorAttachment) || 'cross-platform',
            username: user.username,
            rpName: value === null || value === void 0 ? void 0 : value.rpName,
            userId: user.userId
        });
        var id = additionalData.user.id;
        this.pendingChallenges[id] = additionalData.challenge;
        this.logger.log('Sende Challenge:', additionalData.challenge);
        throw new errors_1.RegisterException(authentication_types_1.AuthenticationType.FIDO, { fido: additionalData });
    };
    FidoAuthenticator.prototype.onResponse = function (user, value) {
        var challenge = '';
        try {
            var clientDataJSON = JSON.parse(base_coding_1.Base64.decode(value.response.clientDataJSON));
            challenge = clientDataJSON.challenge;
        }
        catch (e) {
            this.logger.debug('Something went wrong during get challenge:', e);
        }
        this.logger.log("Response erhalten.", "Erwartete Challenge: " + this.pendingChallenges[user.userId]);
        user.fido = custom_fido_library_1.FidoService.verifyAttestationObject(value, {
            challenge: this.pendingChallenges[user.userId],
            origin: this.expectedOrigins
        });
        delete this.pendingChallenges[user.userId];
        return user;
    };
    FidoAuthenticator.prototype.checkSignature = function (user, credential) {
        if (!user.fido || !user.fido.publicKeyPem) {
            throw new errors_1.AuthenticationException("A publickey is needed to authenticate with fido!");
        }
        var expectations = {
            challenge: this.pendingChallenges[user.userId],
            counter: user.fido.counter,
            publicKeyPem: user.fido.publicKeyPem,
            origin: this.expectedOrigins
        };
        var challenge = '';
        try {
            var clientDataJSON = JSON.parse(base_coding_1.Base64.decode(credential.response.clientDataJSON));
            challenge = clientDataJSON.challenge;
        }
        catch (e) {
            this.logger.debug('Something went wrong during get challenge:', e);
        }
        this.logger.log("Response erhalten.", "Erwartete Challenge: " + this.pendingChallenges[user.userId]);
        custom_fido_library_1.FidoService.verifySignature(credential, expectations);
        delete this.pendingChallenges[user.userId];
    };
    return FidoAuthenticator;
}(base_authenticator_1.BaseAuthenticator));
exports.FidoAuthenticator = FidoAuthenticator;
