"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPaddingToMessage = exports.sha1 = exports.hmac = void 0;
const utils_1 = require("../utils");
const BLOCK_SIZE = 64;
const OUTPUT_LENGTH = 20;
const IPAD = 0x36;
const OPAD = 0x5c;
const k0 = 0x5a827999;
const k1 = 0x6ed9eba1;
const k2 = 0x8f1bbcdc;
const k3 = 0xca62c1d6;
function hmac(key, message, hash) {
    if (key.length < OUTPUT_LENGTH) {
        console.warn(`Key should be at least ${OUTPUT_LENGTH} bytes long`);
    }
    if (key.length > BLOCK_SIZE) {
        key = hash(key);
    }
    const ipad = IPAD.toString(16).repeat(BLOCK_SIZE);
    const opad = OPAD.toString(16).repeat(BLOCK_SIZE);
    return hash((parseInt(key) ^ parseInt(opad)).toString(), hash((parseInt(key) ^ parseInt(ipad)).toString(), message));
}
exports.hmac = hmac;
function sha1(message) {
    let h0 = 0x67452301;
    let h1 = 0xefcdab89;
    let h2 = 0x98badcfe;
    let h3 = 0x10325476;
    let h4 = 0xc3d2e1f0;
    const paddedMessage = addPaddingToMessage(message);
    console.log('paddedMessage', paddedMessage, paddedMessage.length);
    const words = [];
    const numberWords = [];
    for (let i = 0; i < 16; ++i) {
        const word = paddedMessage.substr(i * 8, 8);
        console.log('word to words', word, parseInt(word, 16));
        words.push(word);
        numberWords.push(parseInt(word, 16));
    }
    for (let t = 16; t < 80; ++t) {
        const word = leftRotate(parseInt(words[t - 3], 16) ^
            parseInt(words[t - 8], 16) ^
            parseInt(words[t - 14], 16) ^
            parseInt(words[t - 16], 16), 1);
        const nWord = leftRotate(numberWords[t - 3] ^ numberWords[t - 8] ^ numberWords[t - 14] ^ numberWords[t - 16], 1);
        console.log('word:', word, modulo(word, Math.pow(2, 32)));
        console.log('nWord', nWord, modulo(nWord, Math.pow(2, 32)));
        words.push(word.toString(16));
        numberWords.push(nWord);
    }
    console.log('words', words);
    console.log('nWords', numberWords);
    let a = h0;
    let b = h1;
    let c = h2;
    let d = h3;
    let e = h4;
    for (let t = 0; t < 80; ++t) {
        let fn = null;
        let k = 0;
        if (t < 20) {
            k = k0;
            fn = f0;
        }
        else if (t < 40) {
            k = k1;
            fn = f1;
        }
        else if (t < 60) {
            k = k2;
            fn = f2;
        }
        else {
            k = k3;
            fn = f3;
        }
        const temp = (leftRotate(a, 5) + fn(b, c, d) + e + parseInt(words[t], 16) + k) | 0;
        e = d;
        d = c;
        c = leftRotate(b, 30);
        b = a;
        a = temp;
    }
    h0 = (h0 + a) | 0;
    h1 = (h1 + b) | 0;
    h2 = (h2 + c) | 0;
    h3 = (h3 + d) | 0;
    h4 = (h4 + e) | 0;
    console.log('hs', h0, h1, h2, h3, h4);
    const digest = h0 << 128 || h1 << 96 || h2 << 64 || h3 << 32 || h4;
    return digest.toString(16);
}
exports.sha1 = sha1;
function f0(b, c, d) {
    return (b & c) | (~b & d);
}
function f1(b, c, d) {
    return b ^ c ^ d;
}
function f2(b, c, d) {
    return (b & c) | (b & d) | (c & d);
}
function f3(b, c, d) {
    return b ^ c ^ d;
}
function leftRotate(word, rotation) {
    return (word << rotation) | (word >>> (32 - rotation));
}
function addPaddingToMessage(message) {
    const BITS_OF_LENGTH = 64;
    const SHA1_BITS = 512;
    const binary = toBinary(message) + '1';
    console.log('binary', binary);
    const length = message.length;
    const binaryLength = utils_1.addLeadingZeros(length.toString(2), BITS_OF_LENGTH);
    console.log('length:', length, binaryLength);
    const paddedMessage = `${binary}${utils_1.addLeadingZeros('', SHA1_BITS - (binary.length + BITS_OF_LENGTH))}${binaryLength}`;
    return convertBinaryToHex(paddedMessage);
}
exports.addPaddingToMessage = addPaddingToMessage;
function modulo(integer, base) {
    if (integer < 0) {
        return integer + base;
    }
    else {
        return integer % base;
    }
}
function stringToHex(toConvert) {
    let result = '';
    for (let i = 0; i < toConvert.length; ++i) {
        result = result.concat(toConvert.charCodeAt(i).toString(16));
    }
    return result;
}
function convertBinaryToDecimal(toConvert) {
    let result = '';
    for (let i = 0; i < toConvert.length / 4; ++i) {
        result = result.concat(parseInt(toConvert.substr(i * 4, 4), 2).toString(10));
    }
    return result;
}
function convertBinaryToHex(toConvert) {
    let result = '';
    for (let i = 0; i < toConvert.length / 4; ++i) {
        result = result.concat(parseInt(toConvert.substr(i * 4, 4), 2).toString(16));
    }
    return result;
}
function isNumber(input) {
    return isHexal(input);
}
function isHexal(input) {
    return /^[0-9A-F]+$/g.test(input);
}
function isOctal(input) {
    return /^[0-7]+$/g.test(input);
}
function isDecimal(input) {
    return /^[0-9]+$/g.test(input);
}
function isBinary(input) {
    return /^[0-1]+$/g.test(input);
}
function getRadix(input) {
    if (isBinary(input)) {
        return 2;
    }
    if (isOctal(input)) {
        return 8;
    }
    if (isDecimal(input)) {
        return 10;
    }
    if (isHexal(input)) {
        return 16;
    }
    throw new Error(`Not a number: ${input}`);
}
function toBinary(input) {
    if (isBinary(input)) {
        return input;
    }
    const binary = [];
    for (let i = 0; i < input.length; ++i) {
        const char = input.charCodeAt(i).toString(2);
        binary.push(char);
    }
    return binary.join('');
}
function toNumber(input) {
    return parseInt(input, getRadix(input));
}
//# sourceMappingURL=hmac.js.map