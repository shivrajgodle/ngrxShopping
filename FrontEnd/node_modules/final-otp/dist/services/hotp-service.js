"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HotpService = void 0;
const tslib_1 = require("tslib");
const base_coding_1 = require("base-coding");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const utils_1 = require("../utils");
const hotp_1 = require("../models/hotp");
var HotpService;
(function (HotpService) {
    function create(secret, counter, args) {
        const digits = args && args.digits ? args.digits : 6;
        const expiresIn = args === null || args === void 0 ? void 0 : args.expiresIn;
        if (utils_1.isBase32(secret)) {
            secret = base_coding_1.Base32.decode(secret);
        }
        if (!secret) {
            console.warn('No secret provided to generate an hotp.\n\r\n\rReturn.');
            return;
        }
        if (secret.length < 160) {
            console.warn('RFC4226 recommends, that the length of a secret is at least 160 bits.');
        }
        const hmacResult = createHmac(secret, counter);
        let hotp = truncate(hmacResult, digits);
        hotp = utils_1.addLeadingZeros(hotp, digits);
        return new hotp_1.Hotp({ counter, secret, value: hotp, expiresIn, verifyFn: verify });
    }
    HotpService.create = create;
    function verify(code, secret, counter) {
        if (code.length < 6 || code.length > 8) {
            throw new Error('Undefined length of code.');
        }
        const comparison = create(secret, counter, { digits: code.length });
        return comparison ? code === comparison.value : false;
    }
    HotpService.verify = verify;
    function createHmac(secret, counter) {
        if (typeof counter === 'string') {
            counter = parseInt(counter, 10);
        }
        return crypto_1.default
            .createHmac('sha1', secret)
            .update(Buffer.from(utils_1.convertNumberIntoBytes(counter)))
            .digest('hex');
    }
    function truncate(hmacResult, digits = 6) {
        const offset = (parseInt(hmacResult.slice(-2), 16) & 0xf) * 2;
        const binCode = ((parseInt(hmacResult.substr(offset, 2), 16) & 0x7f) << 24) |
            ((parseInt(hmacResult.substr(offset + 2, 2), 16) & 0xff) << 16) |
            ((parseInt(hmacResult.substr(offset + 4, 2), 16) & 0xff) << 8) |
            (parseInt(hmacResult.substr(offset + 6, 2), 16) & 0xff);
        const hotp = binCode % Math.pow(10, digits);
        return `${hotp}`;
    }
})(HotpService = exports.HotpService || (exports.HotpService = {}));
//# sourceMappingURL=hotp-service.js.map